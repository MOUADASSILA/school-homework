# -*- coding: utf-8 -*-
"""NetworkMeasures.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dUYoFFNmY1KYmePg4n_DJLuaDYrVPUEF

Import NetworkX and numpy libraries
"""

import networkx as nx

import numpy as np

#matplotlib library in order to just plot the bar  graph.
import matplotlib.pyplot as plt

"""# Network Measures via NetworkX library

*   Degree and degree distribution
*   Clustering coefficient
*   Node centrality measures
*   Other helper functions
"""

#initializing a graph
G= nx.karate_club_graph() # a sample unweighted and undirected graph
nx.draw(G)

print(G.nodes)

#degree of node 0
print(G.degree[0])

"""# Degree Distribution"""

#degree of all nodes
print(G.degree())  # (node, degree)

#scale the node sizes according to its degree
nx.draw(G, node_size=[G.degree(i)*100 for i in G.nodes], with_labels=True)

#Degree distribution
# max degree
degree_sequence = sorted((d for (n,d) in G.degree()), reverse=True)
dmax=max(degree_sequence)
print(dmax)

print(degree_sequence)

#we need the unique values of the degree and
#how many times a node obtains this degree.
unique_degree_sequence = np.unique(degree_sequence, return_counts=True)
print(unique_degree_sequence)
#the first array represents the unique values
#the second array tells us  the count for each of the corresponding   values

#plotting degree histogram
plt.bar(unique_degree_sequence[0],unique_degree_sequence[1])
plt.title("Degree histogram")
plt.xlabel("Degree")
plt.ylabel("#of Nodes")

plt.show()

#degree distribution
probabilities=[d/sum(unique_degree_sequence[1]) for d in unique_degree_sequence[1]]
print(probabilities)
print(sum(probabilities))

plt.bar(unique_degree_sequence[0],probabilities)
plt.title("Degree histogram")
plt.xlabel("Degree")
plt.ylabel("Probabilities")

plt.show()
#the distribution is same, but now the  values for each of the degree is restricted between 0 and  1 since its a probability.

"""# Clustering coefficient

Clustering coeffient tells us how much the neighbours of the node are connected.
"""

one_hop_neighbors = nx.ego_graph(G,0, radius=1,center= True, undirected=True)
nx.draw(one_hop_neighbors, with_labels=True)

nodes = list(one_hop_neighbors.nodes())
nodes.remove(0)

one_hop_neighbors_subgraph = G.subgraph(nodes)
nx.draw(one_hop_neighbors_subgraph, with_labels=True)

actual_edges= len(one_hop_neighbors_subgraph.edges())
n= len(nodes)

possible_edges=(n*(n-1))/2

print(actual_edges, possible_edges)

clustering_coefficient=actual_edges/possible_edges
print(clustering_coefficient)

#NetworkX's clustering coefficient calculation
## clustering coefficient of a node
print(nx.clustering(G,0))

#NetworkX's clustering coefficient calculation
## clustering coefficient of ALL node
print(nx.clustering(G))

nx.draw(G, node_size=[nx.clustering(G,i)*1000 for i in G.nodes], with_labels=True)



"""# Centrality Measures

We might want to see how the node looks like globally in the structure of the network.  So, we can use centrality measures

## Degree Centrality
"""

deg_0=G.degree(0)
n= G.number_of_nodes()
print(deg_0,n-1)

print((deg_0/(n-1)))

print(nx.degree_centrality(G)) #https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.degree_centrality.html

"""## Closeness Centrality"""

#closeness centrality basically tells us about the reach of a node
N=len(G.nodes)
nodes= G.nodes

sum_degree_0=0
for n in nodes:
  if (n!=0):
    sum_degree_0 += nx.shortest_path_length(G, source =0, target=n)
    #sum of all the shortest  distance from 0 to all the other nodes

print(N, sum_degree_0)

closenessCentrality_0= (N-1)/sum_degree_0
print(closenessCentrality_0)

#NetworkX's closeness centrality calculation
## closeness centrality of a node
print(nx.closeness_centrality(G))

nx.draw(G, node_size=[i*1000 for i in nx.closeness_centrality(G).values()], with_labels=True)
#we see that almost the nodes are  getting a similar value for closeness centrality.
#This is because the graph is a  connected component in itself
#and all the nodes are basically reachable from  all other nodes and
#if the connections of the graph are strong that is most of the nodes are  connected to the most of the other nodes
#or not directly connected, but may be reachable.
#So, that is why the closeness centrality  is almost similar for all the nodes.

"""## Betweenness Centrality

"""

#betweenness centrality basically tells us that how many times a particular  node need to be passed
#to get from ah one node to another node.
#So, that is how many times a particular node comes in between the shortest path between  any other two nodes
print(nx.betweenness_centrality(G))

nx.draw(G, node_size= [i*5000 for i in nx.betweenness_centrality(G).values()], with_labels=True)

"""## PageRank"""

#PageRank
print(nx.pagerank(G))

nx.draw(G, node_size= [i*5000 for i in nx.pagerank(G).values()], with_labels=True)

"""# Other Helper Functions

## Diameter of a network
"""

print([i for i in nx.shortest_path_length(G)])

print(nx.diameter(G))

"""## Density of a network"""

print(nx.density(G))

"""## Connected Components"""

#we get a connected component  of 1 that is each node is reachable by all the other nodes
print(nx.number_connected_components(G))

"""A lot of network measures from NetworkX, but  there are a a number of more attributes that can be explored in the NetworkX library and  I would leave it to you to explore all the other  
components.

# Measuring Structural Equivalance

## Common neighbors
"""

commonNeighbours= sorted(nx.common_neighbors(G,0,33))
print(commonNeighbours)

len(commonNeighbours)

"""##Jaccard Similarity

"""

#https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.link_prediction.jaccard_coefficient.html
jaccardCoefficient = nx.jaccard_coefficient(G, [(0, 33)])

for u, v, p in jaccardCoefficient:
    print(f"({u}, {v}) -> {p:.8f}")

"""## Cosine Similarity"""

#there is no predefined function in NetworkX
#you should create a fucntion for gauging the cosine similarity